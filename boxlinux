#!/usr/bin/env python
from xml.dom.minidom import parseString
import sys
import os
import json
import requests
import argparse
import threading

proxies = {"":"","":""}


class boxlinux():

	def __init__(self):
		self.apikey = "l7c2il3sxmetf2ielkyxbvc2k4nqqkm4"
		self.version = "0.1"
		self.homeDir = os.path.expanduser("~")
		self.auth_token=None
		self.proxies=None
		self.saveDir=None
		if(os.name=="nt"):
			self.separator = "\\"
		else:
			self.separator="/"		
		#ArgumentParser setup
		parser = argparse.ArgumentParser(description="")
		parser.add_argument('-dl', metavar='filename', type=str, dest='dlFileName', help="Filename to download (Needs --dir if file in different dir)")
		parser.add_argument('-dla', help="Download all files", action='store_true')
		parser.add_argument('-u', metavar='filename', type=str, dest='ulFileName', help="Filename to upload")
		parser.add_argument('--setup', help="Setup for use", action='store_true')
		parser.add_argument('-lsh', help="List filenames for human view", action='store_true')
		parser.add_argument('-ls', help="Print filenames on Box to stdout", action='store_true')
		parser.add_argument('--http-proxy', metavar='PROXYIP', type=str, dest='http_proxy', help="HTTP proxy info")
		parser.add_argument('--https-proxy', metavar='PROXYIP', type=str, dest='https_proxy', help="HTTPS proxy info")
		parser.add_argument('--getcomm', metavar='filename', type=str, dest='commentFileName', help="Fetch Comments for file")
		parser.add_argument('--mkcomm', metavar='comment', type=str, dest='comment', help="Use with --dir as the filename")
		parser.add_argument('--mkdir', metavar='FOLDERNAME' , type=str, dest='newFolder', help="Creates New folder on Box")
		parser.add_argument('--rmdir', metavar='Folder Name', type=str, dest='delFolder', help="Deletes folder on Box")
		parser.add_argument('--rm', metavar='FILENAME', type=str, dest='delFile', help="Deleted file on Box")
		parser.add_argument('-c', metavar='Comment', type=str, dest='strComment', help="String to comment with")
		parser.add_argument('--dir', metavar='DIR', type=str, dest='ActionDir', help="Box directory to perform action in/on")
		#parser.add_argument('--sync', help="Sync files", action='store_true')
		parser.add_argument('--version', action='version', version='%(prog)s '+self.version)
		parser.add_argument('--shrtLink', metavar='FILENAME', type=str, dest='shrtLink', help="Make short link for file")
#parser.add_argument
		args = parser.parse_args()
		#print(args)
		if not args.http_proxy==None and not args.https_proxy==None:
			print("Saving proxies")
			self.setup_proxies(args.http_proxy, args.https_proxy)
		try:
			self.init_settings()
		except:
			print("Need to setup or resetup settings file!")
			self.setup()
			return
		if not args.ActionDir:
			self.direct=args.ActionDir			
		if args.lsh:			
			self.ls()
		elif args.ls:
			self.ls_stdout()
		elif args.setup:
			self.setup()
		elif args.dla:			
			self.download_all(self.get_all_file_id())
		elif not args.dlFileName==None:
			if not self.direct==None:
				self.update_json(self.uni_get_name(self.direct, "id", "folder"))
				#self.download_fileid(self.uni_get_name(args.dlFileName, "id", "file"), None)
				self.downloadThreaded(self.uni_get_name(args.dlFileName, "id", "file"), None)
			else:
				#self.download_fileid(self.uni_get_name(args.dlFileName, "id", "file"), None)
				self.downloadThreaded(self.uni_get_name(args.dlFileName, "id", "file"), None)
		elif not args.ulFileName==None:
			if not self.direct==None:
				folderid = self.uni_get_name(self.direct, "id", "folder")
				self.upload(os.getcwd()+self.separator+args.ulFileName, args.ulFileName, folderid)
			else:
				self.upload(os.getcwd()+self.separator+args.ulFileName, args.ulFileName, 0)
		elif args.sync:			
			#download all files in root dir
			#self.download_all(self.get_all_file_id())
			folderList = self.get_folder_list(0)
			j=0			
			tmpbasePath = self.basePath
			for item in range(0, self.rootJSON['item_collection']['total_count']):
				folderID = self.rootJSON['item_collection']['entries'][item]['id']
				print folderID
				folderName = self.rootJSON['item_collection']['entries'][item]['id']
				self.basePath = tmpbasePath+self.separator+folderName
				if j>0:
					if not os.path.exists(self.basePath):
						os.makedirs(self.basePath)
					self.update_json(folderID)
					self.download_all(self.get_all_file_id())
				j=j+1
				
		elif not args.comment==None:
			self.mk_comment(self.uni_get_name(args.comment, "id", "file"), args.strComment)
		elif not args.commentFileName==None:
			self.print_comments(self.get_comments(self.uni_get_name(args.commentFileName, "id", "file")))
		elif not args.newFolder==None:
			if args.ActionDir==None:
				self.mk_new_folder(args.newFolder,0)
			else:
				self.mk_new_folder(args.mkdir, self.uni_get_name(args.ActionDir, "id", "folder"))
		elif not args.delFolder==None:
			self.deletefolder(self.uni_get_name(args.delFolder, "id", "folder"))
		elif not args.delFile==None:
			self.deletefile(self.uni_get_name(args.delFile, "id", "file"))
		elif not args.shrtLink==None:
			googl = googlShort()
			#longURL = uni_get_name(args.shrtLink, 
			#googl.shorten_url(uni_get_name(args.shrtLink, "share
		else:
			print("Try running `boxlinux --help` or `boxlinux --setup`")
	
	def setup(self):
		ticket = self.authenticate()
		print("Open this link in browser and confirm!")
		print("https://www.box.com/api/1.0/auth/"+ticket)
		raw_input("Press enter when approved")
		self.auth_token = self.get_auth_token(ticket)
		self.saveDir = raw_input("Directory to save files in: "+self.homeDir+"/")
		self.save_settings()
		
	
	def ls_stdout(self):
		items = self.get_item_list()
		i=0
		for item in items:
			sys.stdout.write(items['entries'][i]['name'])
			i+=1
	
	def init_settings(self):
		self.load_settings()
		global headers
		headers = {'Authorization' : 'BoxAuth api_key='+self.apikey+'&auth_token='+self.auth_token,}
		self.rootJSON = json.loads(self.get_folder_list(0))
		#print self.rootJSON
		
	def authenticate(self):
		r = requests.get("https://www.box.com/api/1.0/rest?action=get_ticket&api_key="+self.apikey)
		xml = r.content
		dom = parseString(xml)
		ticket = dom.getElementsByTagName('ticket')[0].toxml()
		ticket = ticket.replace('<ticket>', '').replace("</ticket>","")
		return ticket
		
	def load_settings(self):
		f = open(self.homeDir+self.separator+'.boxlinux', 'r')
		jsonData = json.loads(str(f.read()))
		self.saveDir = jsonData['saveDir']
		self.auth_token = jsonData['auth_token']
		f.close()
		self.basePath = self.homeDir+self.separator+self.saveDir
		if not os.path.exists(self.basePath):
			os.makedirs(self.basePath)
		
	def save_settings(self):
		## this becomes problem because it will overwrite the file getting rid of any bitly settings
		f = open(self.homeDir+self.separator+'.boxlinux', 'w')
		data = {"auth_token":self.auth_token, "proxies":self.proxies, "saveDir": self.saveDir}
		f.write(json.dumps(data))
		f.close()
		
	def get_auth_token(self, ticket):
		r = requests.get("https://www.box.com/api/1.0/rest?action=get_auth_token&api_key="+self.apikey+"&ticket="+ticket, proxies=self.proxies)
		xml = r.content
		dom = parseString(xml)
		auth_token = dom.getElementsByTagName('auth_token')[0].toxml()
		auth_token = auth_token.replace('<auth_token>', '').replace("</auth_token>", "")
		return auth_token
	
	def get_folder_list(self, folderid):
		url = self.build_url("folder", str(folderid), None)
		r = requests.get(url=url, headers=headers, proxies=self.proxies)
		return r.content
	
	def print_folder_list(self):
		folderList = self.rootJSON['item_collection']['entries']
		print("Folders##############")
		for i in folderList:
			if(i['type']=="folder"):
				print(i['name']+" ID:"+i['id'])				
	
	def print_file_list(self):
		fileList = self.rootJSON['item_collection']['entries']
		print("Files##############")
		for i in fileList:
			if(i['type']=="file"):
				print(i['name']+" ID:"+i['id'])		
		
	def download_fileid(self, fileid, filepath):
		self.infoprint("Downloading: "+fileid)
		fileid=str(fileid)
		url = self.build_url("file", fileid, "content")
		#print url
		r = requests.get(url=url, headers=headers, proxies=self.proxies)
		filedata = r.content
		filename = self.uni_get_id(fileid, "name", "file")
		f = open(self.basePath+self.separator+filename, 'w')
		f.write(filedata)
		f.close()
	
	def downloadThreaded(self, fileid, filepath):
		self.infoprint("Downloading: "+fileid)
		fileid = str(fileid)
		url = self.build_url("file", fileid, "content")
		dlThread = downloadThread()
		filename = self.uni_get_id(fileid, "name", "file")
		dlThread.setData(fileid, filename, filepath, headers, self.proxies, url, self.separator, self.basePath)
		dlThread.start()
	
	def upload(self, filepath, filename, folderid):
		self.infoprint("Uploading...")
		url = self.build_url("file", "content", None)
		payload = {'filename1': filename, 'folder_id': folderid}
		try:
			data = {filename: open(filepath, 'r')}
		except:
			self.errprint("File selected is not a file or other error")
			return
		r = requests.post(url=url, data=payload, headers=headers, files=data, proxies=self.proxies)
		
	def deletefile(self, fileid):
		try:
			sha1sum = self.get_sha1sum_remote(fileid)
		#self.varprint("Sha1sum of file to be deleted: "+sha1sum)
			url = self.build_url("file", fileid, None)
			headers_ = {'Authorization' : 'BoxAuth api_key='+self.apikey+'&auth_token='+self.auth_token, 'If-Match': sha1sum}
			r = requests.delete(url=url, headers=headers_, proxies=self.proxies)
			print(r.content)
		except:
			self.infoprint('Something bad happened when deleting file...')
		
	def deletefolder(self, folderid):
		print("Deleting Folder with id "+folderid)
		url = build_url("folder", str(folderid)+"?recursive=true", None)
		#varprint(url)
		r = requests.delete(url=url, headers=headers, proxies=self.proxies)
		print(r.content)
	
	def get_all_file_id(self):
		fileList = self.get_item_list()
		j=0
		rtrnList = range(1, fileList['total_count'])
		for i in fileList['entries']:
			if(i['type']=="file"):
				rtrnList[j] = i['id']
				j+=1
		return rtrnList
	
	def get_sha1sum_remote(self, fileid):
		fileList = self.rootJSON['item_collection']['entries']
		for item in fileList:
			if(item['id']==fileid):
				return item['sha1']
	
	def mk_new_folder(self, foldername, parent_folderid):
		url = build_url(itemtype, None, None)
		payload = {'name': ''+foldername+'', 'parent': {'id': parent_folderid}}
		r = requests.post(url=url, data=json.dumps(payload), headers=headers, proxies=self.proxies)
		return r.content
		
	def get_item_url(self, itemid, itemtype):
		if itemtype=="folder" or itemtype=="FOLDER":
			url = build_url(itemtype, itemid, None)
			payload = {'shared_link': {'access': 'Open'}}
			r = requests.put(url=url, data=json.dumps(payload), headers=headers, proxies=self.proxies)
			rtrnval = json.loads(r.content)
			return [rtrnval['shared_link']['url'], rtrnval['shared_link']['download_url']]
		elif itemtype=="file" or itemtype=="FILE":
			url = build_url(itemtype, itemid, None)
			payload = {'shared_link': {'access':'Open'}}
			r = requests.put(url=url, data=json.dumps(payload), headers=headers, proxies=self.proxies)
			rtrnval = json.loads(r.content)
			return [rtrnval['shared_link']['url'],rtrnval['shared_link']['download_url']]
	
	def rm_share_url_item(self, itemid, itemtype):
		if itemtype=="folder" or itemtype=="FOLDER":
			url = build_url(itemtype, itemid, None)
			payload = {'shared_link': None}
			r = requests.put(url=url, data=json.dumps(payload), headers=headers, proxies=self.proxies)
			return r.content
		elif itemtype=="file" or itemtype=="FILE":
			url = build_url(itemtype, itemid, None)
			payload = {'shared_link': None}
			r = requests.put(url=url, data=json.dumps(payload), headers=headers, proxies=self.proxies)
			return r.content
			
		
	def rename_item(self, newname, itemid, itemtype):
		if(itemtype=="file" or itemtype=="FILE"):
			url = build_url(itemtype, itemid, None)
			payload = {'name': newname}
			r = requests.put(url=url, data=json.dumps(payload), headers=headers, proxies=self.proxies)
			return r.content
		elif(itemtype=="folder" or itemtype=="FOLDER"):
			url = build_url(itemtype, itemid, None)
			payload = {'name': newname}
			r = requests.put(url=url, data=json.dumps(payload), headers=headers, proxies=self.proxies)
			return r.content
		
	def get_item_list(self):	
		return self.rootJSON['item_collection']
	
	def uni_get_id(self, itemid, getthis, itemtype):
		files = self.rootJSON['item_collection']['entries']
		for item in files:
			if(item['id']==itemid and item['type']==itemtype):
				return item[getthis]	
		
	def uni_get_name(self, itemname, getthis, itemtype):
		files = self.rootJSON['item_collection']['entries']
		for item in files:
			if(item['name']==itemname and item['type']==itemtype):
				return item[getthis]
		
	def update_json(self, folderid):
		self.infoprint("Moving into new Directory")
		self.rootJSON = json.loads(self.get_folder_list(folderid))
		print self.rootJSON
				
	def setup_proxies(self, http_proxy, https_proxy):
		#httpproxy = raw_input("What is the HTTP proxy?: ")
		#httpsproxy = raw_input("What is the HTTPS proxy?: ")
		self.proxies = {"http": http_proxy, "https": https_proxy,}
		self.save_settings()
		
	def get_comments(self, fileid):
		url = self.build_url("file", fileid, "comments")
		r = requests.get(url=url, headers=headers)
		return json.loads(r.content)
		
	def print_comments(self, comments):
		i=0
		for k in comments['entries']:
			print(comments['entries'][i]['created_by']['name']+" said: "+comments['entries'][i]['message'])
			i+=1
	
	##do not include the s that should be in the URL this will add it
	##as of now this doesn't do XML... will probably end up changing all the ones that still use XML
	def build_url(self, itemtype, itemid, getthis):
		url = "https://api.box.com/2.0/"+str(itemtype)+"s/"
		if not itemid==None:
			url+=str(itemid)
			if not getthis==None:
				url+="/"+str(getthis)
		#varprint(url)
		return url		
			
	def mk_comment(self, fileid, comment):
		url = self.build_url("file", fileid, "comments")
		payload = {"message": comment}
		r = requests.post(url=url, data=json.dumps(payload), headers=headers, proxies=self.proxies)
		
	def download_all(self, file_list):
		j=0
		for i in file_list:
			#print i
			#self.download_fileid(file_list[j], "")
			self.downloadThreaded(file_list[j], "")			
			j+=1
	
	def get_info_item(self, itemid, itemtype):
		if itemtype=="folder" or itemtype=="FOLDER":
			url = "https://api.box.com/2.0/folders/"+str(itemid)+".xml"
			r = requests.get(url=url, headers=headers, proxies=self.proxies)
			return r.content
		elif itemtype=="file" or itemtype=="FILE":
			url = "https://api.box.com/2.0/files/"+str(itemid)+".xml"
			r = requests.get(url=url, headers=headers)
			return r.content
			
	def ls(self):
		self.print_folder_list()
		self.print_file_list()
	
	def list_items_shared(self):
		self.print_file_list(self.print_folder_list(-1, True), False)
	
	def get_local_files():
		return os.listdir(os.getcwd())	
	
	def errprint(self, printthis):	
		print("[ERROR] "+printthis)
		
	def varprint(self, printthis):
		print("[VARCHECK] "+str(printthis))
		
	def infoprint(self, printthis):
		print("[INFO] "+str(printthis))
		
class downloadThread(threading.Thread):
	def setData(self, fileid, filename, filepath, headers, proxies, url, separator, basePath):
		self.fileID = fileid
		self.filename = filename
		self.filepath = filepath
		self.headers = headers
		self.proxies = proxies
		self.url = url
		self.separator = separator
		self.basePath = basePath
	def run(self):
		self.fileID=str(self.fileID)
		r = requests.get(url=self.url, headers=self.headers, proxies=self.proxies)
		filedata = r.content
		f = open(self.basePath+self.separator+self.filename, 'w')
		f.write(filedata)
		f.close()
			

class googlShort():
	def shorten_url(longURL):
		url = "https://www.googleapis.com/urlshortener/v1/url"
		headers = {'Content-type': 'application/json'}
		data = {'longUrl': longURL}
		r = requests.post(url=url, headers=headers, data=json.dumps(data))
		return json.loads(r.content)['id']

class bitlyShort():
	
	def load_api_key():
		self.api_key
		self.username
		f = open(os.getenv("HOME")+'/.boxlinux', 'r')
		settings = json.loads(f.read())
		self.api_key = settings['bitly']
		self.username = settings['username']

	def shorten_url(longUrl):
		longUrl = urllib.quote_plus(longUrl)
		load_api_key()
		url = "https://api-ssl.bitly.com/v3/shorten?longUrl="+longUrl+"&login="+self.username+"&apiKey="+self.api_key
		r = requests.get(url)
		rtrnval = json.loads(r.content)
		#this is quick and dirty, it will break if any changes are made to the bitly API
		rtrnval = json.loads(json.dumps(rtrnval['data']))
		return rtrnval['url']
		
		
		


box = boxlinux()
#dl = box.downloadThread() 
#dl.run()

"""
    BoxLinux; Bringing Box services to the Linux desktop
    Copyright (C) 2012  Sam Sebastian
    
    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""



"""
Dependincies:
python-requests
	in the ubuntu repos it only installs the version for 2.7
	looking for fix for python3.2 now...
python2.7 (duh!)
"""